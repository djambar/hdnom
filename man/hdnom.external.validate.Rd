% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/8.hdnom.external.validate.R
\name{hdnom.external.validate}
\alias{hdnom.external.validate}
\title{Externally Validate High-Dimensional Cox Models with Time-Dependent AUC}
\usage{
hdnom.external.validate(object, x_new, time_new, event_new,
  tauc.type = c("CD", "SZ", "UNO"), tauc.time, trace = TRUE)
}
\arguments{
\item{object}{Model object fitted by \code{hdcox.*()} functions.}

\item{x_new}{Matrix of predictors for the external validation data.}

\item{time_new}{Survival time of the external validation data.
Must be of the same length with the number of rows as \code{x_new}.}

\item{event_new}{Status indicator of the external validation data,
normally 0 = alive, 1 = dead.
Must be of the same length with the number of rows as \code{x_new}.}

\item{tauc.type}{Type of time-dependent AUC.
Including \code{"CD"} proposed by Chambless and Diao (2006).,
\code{"SZ"} proposed by Song and Zhou (2008).,
\code{"UNO"} proposed by Uno et al. (2007).}

\item{tauc.time}{Numeric vector. Time points at which to evaluate
the time-dependent AUC.}
}
\description{
Externally Validate High-Dimensional Cox Models with Time-Dependent AUC
}
\examples{
library("glmnet")
library("survival")

# Load imputed SMART data
data(smart)
x = as.matrix(smart[, -c(1, 2)])[1:500, ]
time = smart$TEVENT[1:500]
event = smart$EVENT[1:500]

# Fit penalized Cox model (lasso penalty) with glmnet
set.seed(1010)
cvfit = cv.glmnet(x, Surv(time, event), family = "cox", nfolds = 5)

# Model validation by bootstrap with time-dependent AUC
# Normally boot.times should be set to 200 or more,
# we set it to 3 here only to save example running time.
val.boot = hdnom.validate(x, time, event, model.type = "lasso",
                          alpha = 1, lambda = cvfit$lambda.1se,
                          method = "bootstrap", boot.times = 3,
                          tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365)

# Model validation by 5-fold cross-validation with time-dependent AUC
val.cv = hdnom.validate(x, time, event, model.type = "lasso",
                        alpha = 1, lambda = cvfit$lambda.1se,
                        method = "cv", nfolds = 5,
                        tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365)

# Model validation by repeated cross-validation with time-dependent AUC
val.repcv = hdnom.validate(x, time, event, model.type = "lasso",
                           alpha = 1, lambda = cvfit$lambda.1se,
                           method = "repeated.cv", nfolds = 5, rep.times = 3,
                           tauc.type = "UNO", tauc.time = seq(0.25, 2, 0.25) * 365)

# bootstrap-based discrimination curves has a very narrow band
print(val.boot)
summary(val.boot)
plot(val.boot)

# k-fold cv provides a more strict evaluation than bootstrap
print(val.cv)
summary(val.cv)
plot(val.cv)

# repeated cv provides similar results as k-fold cv
# but more robust than k-fold cv
print(val.repcv)
summary(val.repcv)
plot(val.repcv)

}
\references{
Chambless, L. E. and G. Diao (2006).
Estimation of time-dependent area under the ROC curve for long-term
risk prediction.
\emph{Statistics in Medicine} 25, 3474--3486.

Song, X. and X.-H. Zhou (2008).
A semiparametric approach for the covariate specific ROC curve with
survival outcome.
\emph{Statistica Sinica} 18, 947--965.

Uno, H., T. Cai, L. Tian, and L. J. Wei (2007).
Evaluating prediction rules for t-year survivors with censored
regression models.
\emph{Journal of the American Statistical Association} 102, 527--537.
}

